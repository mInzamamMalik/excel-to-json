'use strict';

var _xlsx = require('xlsx');

var _xlsx2 = _interopRequireDefault(_xlsx);

var _strings = require('./utils/strings');

var _array = require('./utils/array');

var _lookup = require('./lookup');

var _lookup2 = _interopRequireDefault(_lookup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
* return
 {
	columns: [column1, column2, ...],
	mapColumns: 
	{
		column1: column1_,
		column2: column2_,
		....
	}
 }
 params
 @opts
	filter sheets
		callback acceptsSheet(sheetName) to filter
	header
 		{skipRows: 0} --start row

		mapping: next 2 rows after header for mapping
 			{hasMapping: true}
			ex:
				column1		column2		column3
		        	x 		   			   x
*			 	c1_map					 c3_map
**/
function readHeader(fileName, sheetName, opts) {
	opts = opts || {};
	opts.header = 1;

	var startRow = opts.skipRows || 0;
	var endRow = opts.hasMapping ? startRow + 2 : startRow;
	opts.range = { s: { c: 0, r: startRow }, e: { c: 100, r: endRow } };

	var workbook = _xlsx2.default.readFile(fileName);

	//extract header from the first accepted sheet
	var sheetNameLower = (0, _strings.toLowerAndNoSpace)(sheetName);

	if (!opts.acceptsSheet || opts.acceptsSheet(sheetNameLower)) {
		var data = _xlsx2.default.utils.sheet_to_json(workbook.Sheets[sheetName], opts);

		var result = {
			originalColumns: data[0],
			columns: (0, _array.toLowerAndNoSpaceStringsArray)(data[0]),
			mapColumns: {}
		};

		if (opts.hasMapping) {
			// data[0]: columns header
			// data[1]: 'x' or nothing, 'x' = having mapping
			// data[2]: map to enum/decimal/hex
			for (var i = 0; i < data[0].length; i++) {
				if (data[1][i] === 'x') {
					var columnLower = (0, _strings.toLowerAndNoSpace)(data[0][i]);
					var mapColumnLower = (0, _strings.toLowerAndNoSpace)(data[2][i]);
					result.mapColumns[columnLower] = mapColumnLower;
				}
			}
		}

		return result;
	}

	return null;
}

/**
* return
	for every single sheet
		{
			sheetname1 (lowercase & no space): {
				header: {
					columns: [column1, column2, ...],
					mapColumns:
					{
						column2: column2_,
						column3: column3_',
						...
					}
				},
				data [
					{column1 (lowercase & no space): value1, column2: value2, ...},
					...
				],
			},
			sheet2: {
	
			}
		}
	merging data from multiple sheet
		{
			header: {
				columns: [column1, column2, ...],
				mapColumns:
				{
					column2: column2x,
					column3: column3y',
					...
				}
			},
			data [
				{column1 (lowercase & no space): value1, column2: value2, ...},
				...
			],
		}

parameters		
 @opts
		filter sheets
			callback acceptsSheet(sheetName) to filter
		data in a range
			{range: {s:{c:0, r:0}, e:{c:100, r:100}}}}
			{startRow: 1, endRow: 10}
		merge data from all sheets (ex: by year)
			{mergeData: true}
		skip rows
			{skipRows: 0}
			{specialSkipRows: {sheet1: 1, sheet3: 1}}
*
**/
function read(fileNames, opts) {
	var data = {};

	opts = opts || {};
	if (opts.startRow && opts.endRow) {
		opts.range = { s: { c: 0, r: opts.startRow }, e: { c: 100, r: opts.endRow } };
	}

	var files = fileNames instanceof Array ? fileNames : [fileNames];

	return new Promise(function (resolve, reject) {
		var promises = files.map(function (file) {
			return readOneFile(file, opts);
		});

		Promise.all(promises).then(function (results) {
			resolve(mergeSameData(results));
		});
	});
}

function mergeSameData(arr) {
	var result = {};

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var o = _step.value;

			for (var prop in o) {
				var _result$prop$data;

				if (result[prop]) (_result$prop$data = result[prop].data).push.apply(_result$prop$data, _toConsumableArray(o[prop].data));else result[prop] = o[prop];
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return result;
}

function readOneFile(fileName, opts) {
	return new Promise(function (resolve, reject) {
		var workbook = _xlsx2.default.readFile(fileName);

		//read data for each accepted sheet
		var promises = workbook.SheetNames.filter(function (sheetName) {
			console.log((0, _strings.toLowerAndNoSpace)(sheetName));
			return !opts.acceptsSheet || opts.acceptsSheet((0, _strings.toLowerAndNoSpace)(sheetName));
		}).map(function (sheetName) {
			console.log(sheetName);
			return readOneSheet(workbook, fileName, sheetName, opts);
		});

		Promise.all(promises).then(function (results) {
			resolve(mergeSameData(results));
		});
	});
}

function readOneSheet(workbook, fileName, sheetName, opts) {
	//console.log(`loaded sheet #${fileName} #${sheetName}`)

	var sheetData = {};
	var sheetNameLower = (0, _strings.toLowerAndNoSpace)(sheetName);

	var skipRows = opts.specialSkipRows && opts.specialSkipRows[sheetNameLower] ? opts.specialSkipRows[sheetNameLower] : opts.skipRows || 0;

	//header to read for current sheet
	var header = readHeader(fileName, sheetName, {
		skipRows: skipRows,
		hasMapping: opts.hasMapping
	});

	opts.header = header.columns;

	var data = _xlsx2.default.utils.sheet_to_json(workbook.Sheets[sheetName], opts);

	data.splice(0, opts.hasMapping ? skipRows + 3 : skipRows + 1);

	//if merge data, result as {header, data}
	if (opts.mergeData) {
		if (!sheetData.all) {
			sheetData.all = {
				header: header,
				data: data
			};
		} else {
			sheetData.all.data.push(data);
		}
	} else {
		/*
  not merge, result as
  {
  	sheet1: {header, data},
  	sheet2: {header, data},
  	...
  }
  */

		if (sheetData[sheetNameLower]) {
			sheetData[sheetNameLower].data.push(data);
		} else {
			sheetData[sheetNameLower] = {
				header: header,
				data: data
			};
		}
	}

	return Promise.resolve(sheetData);
}

module.exports = {
	read: read,
	Lookup: _lookup2.default
};